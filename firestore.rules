rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Helper function to check if user document exists
    function userDocumentExists() {
      return isAuthenticated() && 
        exists(/databases/$(database)/documents/users/$(request.auth.uid));
    }
    
    // Helper function to get user's family ID (safely handles missing document or field)
    function getUserFamilyId() {
      return userDocumentExists() && 
        'familyId' in get(/databases/$(database)/documents/users/$(request.auth.uid)).data ?
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.familyId :
        null;
    }
    
    // Helper function to check if user belongs to a family
    function belongsToFamily(familyId) {
      return isAuthenticated() && 
        userDocumentExists() &&
        getUserFamilyId() != null &&
        getUserFamilyId() is string &&
        getUserFamilyId() == familyId;
    }
    
    // Helper function to check if user is Banker or Admin (safely handles missing document)
    function isBankerOrAdmin() {
      return isAuthenticated() && 
        userDocumentExists() &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.roles.hasAny(['banker', 'admin']);
    }
    
    // Users collection - users can read/write their own data
    match /users/{userId} {
      // Users can read their own document
      allow read: if isAuthenticated() && request.auth.uid == userId;
      
      // Users can read other users' documents (needed for family members list and invitation verification)
      allow read: if isAuthenticated();
      
      // Users can write their own document
      allow write: if isAuthenticated() && request.auth.uid == userId;
      
      // Allow Bankers/Admins to update roles field of other users in their family
      allow update: if isAuthenticated() && 
        request.auth.uid == userId ||
        (isBankerOrAdmin() && 
         belongsToFamily(resource.data.familyId) &&
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['roles']));
      
      // Allow Bankers/Admins to update relationship field of other users in their family
      allow update: if isAuthenticated() && 
        request.auth.uid != userId &&
        isBankerOrAdmin() &&
        belongsToFamily(resource.data.familyId) &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['relationship']);
    }
    
    // Family collections - tasks, events, messages, etc.
    match /families/{familyId} {
      // Allow read if user belongs to the family
      allow read: if belongsToFamily(familyId);
      
      // Allow creating family document if it doesn't exist (for first job creation)
      allow create: if belongsToFamily(familyId) &&
        request.resource.data.walletBalance is number;
      
      // Allow updating walletBalance field for family members (for job creation/approval)
      // This handles both updates to existing documents and set() with merge on new documents
      allow update: if belongsToFamily(familyId) && 
        request.resource.data.walletBalance is number &&
        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['walletBalance']) ||
         !exists(/databases/$(database)/documents/families/$(familyId)));
      
      // Tasks subcollection
      match /tasks/{taskId} {
        allow read: if belongsToFamily(familyId);
        allow create: if belongsToFamily(familyId) && 
          request.resource.data.createdBy == request.auth.uid;
        allow update: if belongsToFamily(familyId) && 
          (resource.data.createdBy == request.auth.uid ||
           resource.data.claimedBy == request.auth.uid ||
           resource.data.assignedTo == request.auth.uid ||
           // Allow any family member to complete tasks that don't require claim
           (resource.data.requiresClaim == false || !('requiresClaim' in resource.data)) ||
           // Allow any family member to claim a job (set claimedBy and claimStatus)
           // Permissive rule: allow if user is setting themselves as claimer
           (request.resource.data.claimedBy == request.auth.uid &&
            (request.resource.data.claimStatus == 'pending' ||
             request.resource.data.claimStatus == 'approved' ||
             request.resource.data.claimStatus == 'rejected' ||
             !('claimStatus' in request.resource.data))));
        allow delete: if belongsToFamily(familyId) && 
          resource.data.createdBy == request.auth.uid;
        
        // Task dependencies subcollection
        match /dependencies/{dependencyId} {
          allow read: if belongsToFamily(familyId);
          allow create: if belongsToFamily(familyId);
          allow update: if belongsToFamily(familyId);
          allow delete: if belongsToFamily(familyId);
        }
      }
      
      // Calendar events subcollection
      match /events/{eventId} {
        allow read: if belongsToFamily(familyId);
        allow create: if belongsToFamily(familyId) && 
          request.resource.data.createdBy == request.auth.uid;
        // Allow any family member to update events (for collaboration and duplicate cleanup)
        // Ownership checks are handled at the application level
        allow update: if belongsToFamily(familyId);
        allow delete: if belongsToFamily(familyId) && 
          (resource.data.eventOwnerId == request.auth.uid ||
           resource.data.createdBy == request.auth.uid ||
           // Allow admin/banker to delete events for duplicate cleanup operations
           isBankerOrAdmin());
        
        // Event-specific chat messages subcollection
        match /chats/{messageId} {
          // Helper function to check if user has access to event chat
          // Access granted to: event creator + invitedMemberIds
          function hasEventChatAccess() {
            let eventData = get(/databases/$(database)/documents/families/$(familyId)/events/$(eventId)).data;
            let createdBy = eventData.createdBy;
            let invitedMemberIds = eventData.invitedMemberIds is list ? eventData.invitedMemberIds : [];
            return request.auth != null && 
              (createdBy == request.auth.uid || 
               request.auth.uid in invitedMemberIds);
          }
          
          // Helper function to check if user is Admin
          function isAdmin() {
            return isAuthenticated() && 
              userDocumentExists() &&
              get(/databases/$(database)/documents/users/$(request.auth.uid)).data.roles.hasAny(['Admin', 'admin']);
          }
          
          // Read: Only event creator + invited members
          allow read: if belongsToFamily(familyId) && hasEventChatAccess();
          
          // Create: Only event creator + invited members, and sender must be current user
          allow create: if belongsToFamily(familyId) && 
            hasEventChatAccess() &&
            request.resource.data.senderId == request.auth.uid;
          
          // Update: Only message sender can edit their own messages
          allow update: if belongsToFamily(familyId) && 
            hasEventChatAccess() &&
            resource.data.senderId == request.auth.uid;
          
          // Delete: Message sender OR admin can delete
          allow delete: if belongsToFamily(familyId) && 
            hasEventChatAccess() &&
            (resource.data.senderId == request.auth.uid || isAdmin());
        }
      }
      
      // Chat messages subcollection
      match /messages/{messageId} {
        allow read: if belongsToFamily(familyId);
        allow create: if belongsToFamily(familyId) && 
          request.resource.data.senderId == request.auth.uid;
        allow update: if belongsToFamily(familyId) && 
          resource.data.senderId == request.auth.uid;
        allow delete: if belongsToFamily(familyId) && 
          resource.data.senderId == request.auth.uid;
        
        // Message reactions subcollection
        match /reactions/{reactionId} {
          allow read: if belongsToFamily(familyId);
          allow create: if belongsToFamily(familyId) && 
            request.resource.data.userId == request.auth.uid;
          allow update: if belongsToFamily(familyId) && 
            resource.data.userId == request.auth.uid;
          allow delete: if belongsToFamily(familyId) && 
            resource.data.userId == request.auth.uid;
        }
        
        // Message replies subcollection (for threading)
        match /replies/{replyId} {
          allow read: if belongsToFamily(familyId);
          allow create: if belongsToFamily(familyId) && 
            request.resource.data.senderId == request.auth.uid;
          allow update: if belongsToFamily(familyId) && 
            resource.data.senderId == request.auth.uid;
          allow delete: if belongsToFamily(familyId) && 
            resource.data.senderId == request.auth.uid;
        }
      }
      
      // Private messages subcollection
      match /privateMessages/{chatId} {
        allow read: if belongsToFamily(familyId);
        allow create: if belongsToFamily(familyId);
        // Nested messages collection
        match /messages/{messageId} {
          allow read: if belongsToFamily(familyId);
          allow create: if belongsToFamily(familyId) && 
            request.resource.data.senderId == request.auth.uid;
          allow update: if belongsToFamily(familyId) && 
            resource.data.senderId == request.auth.uid;
          allow delete: if belongsToFamily(familyId) && 
            resource.data.senderId == request.auth.uid;
        }
        // Read status subcollection - users can write their own read status
        match /readStatus/{userId} {
          allow read: if belongsToFamily(familyId);
          allow write: if belongsToFamily(familyId) && 
            request.auth.uid == userId;
        }
      }
      
      // Family members location subcollection
      match /members/{memberId} {
        allow read: if belongsToFamily(familyId);
        allow write: if belongsToFamily(familyId) && 
          request.auth.uid == memberId;
      }
      
      // Game stats subcollection
      match /game_stats/{userId} {
        allow read: if belongsToFamily(familyId);
        // Allow create/update if document ID matches auth uid (user updating their own stats)
        // The document ID is the userId, so we check that directly
        allow create, update: if belongsToFamily(familyId) && 
          userId == request.auth.uid;
      }
      
      // Photo albums subcollection
      match /albums/{albumId} {
        allow read: if belongsToFamily(familyId);
        allow create: if belongsToFamily(familyId) && 
          request.resource.data.createdBy == request.auth.uid;
        allow update: if belongsToFamily(familyId) && 
          (resource.data.createdBy == request.auth.uid ||
           request.resource.data.diff(resource.data).affectedKeys().hasOnly(['coverPhotoId', 'photoCount', 'lastPhotoAddedAt']));
        allow delete: if belongsToFamily(familyId) && 
          resource.data.createdBy == request.auth.uid;
      }
      
      // Photos subcollection
      match /photos/{photoId} {
        allow read: if belongsToFamily(familyId);
        allow create: if belongsToFamily(familyId) && 
          request.resource.data.uploadedBy == request.auth.uid;
        allow update: if belongsToFamily(familyId) && 
          (resource.data.uploadedBy == request.auth.uid ||
           request.resource.data.diff(resource.data).affectedKeys().hasOnly(['viewCount', 'lastViewedAt']));
        allow delete: if belongsToFamily(familyId) && 
          resource.data.uploadedBy == request.auth.uid;
        
        // Photo comments subcollection
        match /comments/{commentId} {
          allow read: if belongsToFamily(familyId);
          allow create: if belongsToFamily(familyId) && 
            request.resource.data.authorId == request.auth.uid;
          allow update: if belongsToFamily(familyId) && 
            resource.data.authorId == request.auth.uid;
          allow delete: if belongsToFamily(familyId) && 
            resource.data.authorId == request.auth.uid;
        }
      }
      
      // Payout requests subcollection
      match /payoutRequests/{requestId} {
        allow create: if belongsToFamily(familyId) && 
          request.resource.data.userId == request.auth.uid &&
          request.resource.data.status == 'pending' &&
          request.resource.data.amount is number &&
          request.resource.data.amount > 0;
        allow read: if belongsToFamily(familyId) && 
          (resource.data.userId == request.auth.uid || isBankerOrAdmin());
        allow update: if belongsToFamily(familyId) && 
          isBankerOrAdmin() &&
          resource.data.userId == request.resource.data.userId &&
          resource.data.amount == request.resource.data.amount;
        allow delete: if false; // No delete (keep for history)
      }
      
      // Approved payouts subcollection
      match /payouts/{payoutId} {
        allow create: if belongsToFamily(familyId) && isBankerOrAdmin() &&
          request.resource.data.userId is string &&
          request.resource.data.amount is number &&
          request.resource.data.amount > 0;
        allow read: if belongsToFamily(familyId) && 
          (resource.data.userId == request.auth.uid || isBankerOrAdmin());
        allow update: if false; // Immutable records
        allow delete: if false; // Immutable records
      }
      
      // Recurring payments subcollection
      match /recurringPayments/{paymentId} {
        allow create: if belongsToFamily(familyId) && isBankerOrAdmin() &&
          request.resource.data.fromUserId == request.auth.uid &&
          request.resource.data.toUserId is string &&
          request.resource.data.amount is number &&
          request.resource.data.amount > 0 &&
          request.resource.data.frequency in ['weekly', 'monthly'] &&
          request.resource.data.isActive == true;
        allow read: if belongsToFamily(familyId) && 
          (resource.data.toUserId == request.auth.uid || 
           resource.data.fromUserId == request.auth.uid ||
           isBankerOrAdmin());
        allow update: if belongsToFamily(familyId) && isBankerOrAdmin() &&
          resource.data.fromUserId == request.resource.data.fromUserId &&
          resource.data.toUserId == request.resource.data.toUserId &&
          resource.data.amount == request.resource.data.amount &&
          resource.data.frequency == request.resource.data.frequency;
        allow delete: if false; // Keep for history
      }
      
      // Pocket money payments subcollection
      match /pocketMoneyPayments/{paymentRecordId} {
        allow create: if belongsToFamily(familyId) && isBankerOrAdmin() &&
          request.resource.data.fromUserId is string &&
          request.resource.data.toUserId is string &&
          request.resource.data.amount is number &&
          request.resource.data.amount > 0;
        allow read: if belongsToFamily(familyId) && 
          (resource.data.toUserId == request.auth.uid || 
           resource.data.fromUserId == request.auth.uid ||
           isBankerOrAdmin());
        allow update: if false; // Immutable records
        allow delete: if false; // Immutable records
      }
      
      // Family wallet document
      match /wallet/{walletId} {
        allow read: if belongsToFamily(familyId);
        allow write: if belongsToFamily(familyId) && isBankerOrAdmin();
      }
      
      // Notifications subcollection
      match /notifications/{notificationId} {
        allow read: if belongsToFamily(familyId) && 
          resource.data.userId == request.auth.uid;
        allow create: if belongsToFamily(familyId);
        allow update: if belongsToFamily(familyId) && 
          resource.data.userId == request.auth.uid;
        allow delete: if belongsToFamily(familyId) && 
          resource.data.userId == request.auth.uid;
      }
      
      // Hubs subcollection
      match /hubs/{hubId} {
        allow read: if belongsToFamily(familyId);
        allow create: if belongsToFamily(familyId) && 
          request.resource.data.creatorId == request.auth.uid;
        allow update: if belongsToFamily(familyId) && 
          (resource.data.creatorId == request.auth.uid ||
           resource.data.memberIds.hasAny([request.auth.uid]));
        allow delete: if belongsToFamily(familyId) && 
          resource.data.creatorId == request.auth.uid;
      }
      
      // Hub invites subcollection
      match /hubInvites/{inviteId} {
        allow read: if belongsToFamily(familyId);
        allow create: if belongsToFamily(familyId);
        allow update: if belongsToFamily(familyId);
        allow delete: if belongsToFamily(familyId);
      }
      
      // Event templates subcollection
      match /eventTemplates/{templateId} {
        allow read: if belongsToFamily(familyId);
        allow create: if belongsToFamily(familyId) && 
          request.resource.data.createdBy == request.auth.uid;
        allow update: if belongsToFamily(familyId) && 
          resource.data.createdBy == request.auth.uid;
        allow delete: if belongsToFamily(familyId) && 
          resource.data.createdBy == request.auth.uid;
      }
    }
    
    // Notifications collection (top-level, for backward compatibility)
    match /notifications/{notificationId} {
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow create: if isAuthenticated();
      allow update: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }
    
    // Hubs collection (top-level, for backward compatibility)
    match /hubs/{hubId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && request.resource.data.creatorId == request.auth.uid;
      allow update: if isAuthenticated() && 
        (resource.data.creatorId == request.auth.uid ||
         resource.data.memberIds.hasAny([request.auth.uid]));
      allow delete: if isAuthenticated() && resource.data.creatorId == request.auth.uid;
      
      // Hub messages subcollection
      match /messages/{messageId} {
        // Helper function to check if user is a hub member
        function isHubMember() {
          return isAuthenticated() && 
            exists(/databases/$(database)/documents/hubs/$(hubId)) &&
            (get(/databases/$(database)/documents/hubs/$(hubId)).data.creatorId == request.auth.uid ||
             request.auth.uid in get(/databases/$(database)/documents/hubs/$(hubId)).data.memberIds);
        }
        
        allow read: if isHubMember();
        allow create: if isHubMember() && 
          request.resource.data.senderId == request.auth.uid;
        allow update: if isHubMember() && 
          resource.data.senderId == request.auth.uid;
        allow delete: if isHubMember() && 
          resource.data.senderId == request.auth.uid;
      }
    }
    
    // Hub invites collection (top-level, for backward compatibility)
    match /hubInvites/{inviteId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated();
      allow update: if isAuthenticated();
      allow delete: if isAuthenticated();
    }
    
    // Privacy activity collection
    match /privacy_activity/{activityId} {
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
    }
    
    // Video calls collection
    match /calls/{hubId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated();
      allow update: if isAuthenticated();
      allow delete: if isAuthenticated();
    }
    
    // Chess games collection
    match /chess_games/{gameId} {
      // Helper function to check if user is involved in the game
      function isGameParticipant() {
        return resource.data.whitePlayerId == request.auth.uid ||
               resource.data.blackPlayerId == request.auth.uid ||
               (resource.data.invitedPlayerId != null && 
                resource.data.invitedPlayerId == request.auth.uid) ||
               request.auth.uid in resource.data.spectators;
      }
      
      // CRITICAL FIX: Allow authenticated users to read ALL chess games
      // This is needed for:
      // 1. Collection queries (.get()) to fetch all games for deletion
      // 2. Stream queries to see waiting/active games
      // Individual document access is still controlled by isGameParticipant() for security
      // But collection-level queries need broader permission
      allow read: if isAuthenticated();
      
      // Users can create games
      allow create: if isAuthenticated() && 
        request.resource.data.whitePlayerId == request.auth.uid;
      
      // Players can update their own games (make moves)
      // Also allow invited players to update (when accepting the invite)
      allow update: if isAuthenticated() && 
        (resource.data.whitePlayerId == request.auth.uid ||
         resource.data.blackPlayerId == request.auth.uid ||
         (resource.data.invitedPlayerId != null && 
          resource.data.invitedPlayerId == request.auth.uid));
      
      // Players can delete their own games (resign/abort)
      // Also allow invited players to delete (when declining the invite)
      // CRITICAL: Allow deletion of waiting games by any authenticated user (for cleanup/admin operations)
      // This enables the "Clear All Chess Data" feature to work properly
      allow delete: if isAuthenticated() && 
        (resource.data.whitePlayerId == request.auth.uid ||
         resource.data.blackPlayerId == request.auth.uid ||
         (resource.data.invitedPlayerId != null && 
          resource.data.invitedPlayerId == request.auth.uid) ||
         // Allow deletion of waiting games by any authenticated user (for cleanup)
         resource.data.status == 'waiting');
    }
    
    // Chess matchmaking queue
    match /chess_matchmaking/{queueId} {
      // Users can read all queue entries (needed for matchmaking)
      allow read: if isAuthenticated();
      
      // Users can create their own queue entry
      allow create: if isAuthenticated() && 
        request.resource.data.userId == request.auth.uid;
      
      // Users can update their own queue entry
      allow update: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
      
      // Users can delete their own queue entry
      allow delete: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
    }
    
    // Chess invites collection (for family chess challenges)
    match /invites/{inviteId} {
      // CRITICAL FIX: Allow authenticated users to read ALL invites
      // This is needed for collection queries (.get()) to fetch all invites for deletion
      // Individual document access can still be filtered client-side for security
      allow read: if isAuthenticated();
      
      // Users can create invites (when challenging someone)
      allow create: if isAuthenticated() && 
        request.resource.data.sender == request.auth.uid;
      
      // Users can update invites they sent or received
      allow update: if isAuthenticated() && 
        (resource.data.sender == request.auth.uid ||
         resource.data.targetUser == request.auth.uid);
      
      // Users can delete invites they sent
      // CRITICAL: Also allow deletion of pending invites by any authenticated user (for cleanup)
      // This enables the "Clear All Chess Data" feature to work properly
      allow delete: if isAuthenticated() && 
        (resource.data.sender == request.auth.uid ||
         resource.data.status == 'pending');
    }
    
    // FCM messages collection (for triggering Cloud Functions)
    match /fcm_messages/{messageId} {
      // Allow authenticated users to create FCM message triggers
      allow create: if isAuthenticated();
      // CRITICAL FIX: Allow authenticated users to read and delete FCM messages
      // This is needed for the "Clear All Chess Data" feature to delete chess-related FCM messages
      allow read: if isAuthenticated();
      allow delete: if isAuthenticated();
      // No updates allowed (immutable)
      allow update: if false;
    }
  }
}

