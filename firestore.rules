rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Helper function to check if user document exists (checks all possible collection paths)
    function userDocumentExists() {
      return isAuthenticated() && (
        exists(/databases/$(database)/documents/users/$(request.auth.uid)) ||
        exists(/databases/$(database)/documents/dev_users/$(request.auth.uid)) ||
        exists(/databases/$(database)/documents/test_users/$(request.auth.uid))
      );
    }
    
    // Helper function to get user's family ID from users collection
    function getUserFamilyIdFromUsers() {
      return isAuthenticated() && 
        exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
        'familyId' in get(/databases/$(database)/documents/users/$(request.auth.uid)).data ?
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.familyId :
        null;
    }
    
    // Helper function to get user's family ID from dev_users collection
    function getUserFamilyIdFromDevUsers() {
      return isAuthenticated() && 
        exists(/databases/$(database)/documents/dev_users/$(request.auth.uid)) &&
        'familyId' in get(/databases/$(database)/documents/dev_users/$(request.auth.uid)).data ?
        get(/databases/$(database)/documents/dev_users/$(request.auth.uid)).data.familyId :
        null;
    }
    
    // Helper function to get user's family ID from test_users collection
    function getUserFamilyIdFromTestUsers() {
      return isAuthenticated() && 
        exists(/databases/$(database)/documents/test_users/$(request.auth.uid)) &&
        'familyId' in get(/databases/$(database)/documents/test_users/$(request.auth.uid)).data ?
        get(/databases/$(database)/documents/test_users/$(request.auth.uid)).data.familyId :
        null;
    }
    
    // Helper function to get user's family ID (safely handles missing document or field)
    // Checks all possible collection paths
    function getUserFamilyId() {
      let familyId = getUserFamilyIdFromUsers();
      return familyId != null ? familyId : (
        getUserFamilyIdFromDevUsers() != null ? getUserFamilyIdFromDevUsers() : getUserFamilyIdFromTestUsers()
      );
    }
    
    // Helper function to check if user belongs to a family
    function belongsToFamily(familyId) {
      return isAuthenticated() && 
        userDocumentExists() &&
        getUserFamilyId() != null &&
        getUserFamilyId() is string &&
        getUserFamilyId() == familyId;
    }
    
    // Helper function to check if user is Banker or Admin (safely handles missing document)
    // Checks all possible collection paths
    function isBankerOrAdmin() {
      return isAuthenticated() && userDocumentExists() && (
        (exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
         'roles' in get(/databases/$(database)/documents/users/$(request.auth.uid)).data &&
         get(/databases/$(database)/documents/users/$(request.auth.uid)).data.roles.hasAny(['banker', 'admin'])) ||
        (exists(/databases/$(database)/documents/dev_users/$(request.auth.uid)) &&
         'roles' in get(/databases/$(database)/documents/dev_users/$(request.auth.uid)).data &&
         get(/databases/$(database)/documents/dev_users/$(request.auth.uid)).data.roles.hasAny(['banker', 'admin'])) ||
        (exists(/databases/$(database)/documents/test_users/$(request.auth.uid)) &&
         'roles' in get(/databases/$(database)/documents/test_users/$(request.auth.uid)).data &&
         get(/databases/$(database)/documents/test_users/$(request.auth.uid)).data.roles.hasAny(['banker', 'admin']))
      );
    }
    
    // Helper function to check if user is Admin (safely handles missing document)
    // Checks all possible collection paths
    function isAdmin() {
      return isAuthenticated() && userDocumentExists() && (
        (exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
         'roles' in get(/databases/$(database)/documents/users/$(request.auth.uid)).data &&
         get(/databases/$(database)/documents/users/$(request.auth.uid)).data.roles.hasAny(['admin', 'Admin'])) ||
        (exists(/databases/$(database)/documents/dev_users/$(request.auth.uid)) &&
         'roles' in get(/databases/$(database)/documents/dev_users/$(request.auth.uid)).data &&
         get(/databases/$(database)/documents/dev_users/$(request.auth.uid)).data.roles.hasAny(['admin', 'Admin'])) ||
        (exists(/databases/$(database)/documents/test_users/$(request.auth.uid)) &&
         'roles' in get(/databases/$(database)/documents/test_users/$(request.auth.uid)).data &&
         get(/databases/$(database)/documents/test_users/$(request.auth.uid)).data.roles.hasAny(['admin', 'Admin']))
      );
    }
    
    // Users collection - users can read/write their own data
    match /users/{userId} {
      // Users can read their own document
      allow read: if isAuthenticated() && request.auth.uid == userId;
      
      // Users can read other users' documents (needed for family members list and invitation verification)
      allow read: if isAuthenticated();
      
      // Users can write their own document
      allow write: if isAuthenticated() && request.auth.uid == userId;
      
      // Allow Bankers/Admins to update roles field of other users in their family
      allow update: if isAuthenticated() && 
        request.auth.uid == userId ||
        (isBankerOrAdmin() && 
         belongsToFamily(resource.data.familyId) &&
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['roles']));
      
      // Allow Bankers/Admins to update relationship field of other users in their family
      allow update: if isAuthenticated() && 
        request.auth.uid != userId &&
        isBankerOrAdmin() &&
        belongsToFamily(resource.data.familyId) &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['relationship']);
      
      // Ignored conflicts subcollection - users can manage their own ignored conflicts
      match /ignoredConflicts/{conflictKey} {
        allow read, write: if isAuthenticated() && request.auth.uid == userId;
      }
      
      // SMS conversations subcollection (premium feature)
      match /sms_conversations/{phoneNumber} {
        allow read, write: if isAuthenticated() && request.auth.uid == userId;
        
        // Messages subcollection
        match /messages/{messageId} {
          allow read, write: if isAuthenticated() && request.auth.uid == userId;
        }
      }
    }
    
    // Dev users collection - same rules as users (for dev environment)
    match /dev_users/{userId} {
      // Users can read their own document
      allow read: if isAuthenticated() && request.auth.uid == userId;
      
      // Users can read other users' documents (needed for family members list and invitation verification)
      allow read: if isAuthenticated();
      
      // Users can write their own document
      allow write: if isAuthenticated() && request.auth.uid == userId;
      
      // Allow Bankers/Admins to update roles field of other users in their family
      allow update: if isAuthenticated() && 
        request.auth.uid == userId ||
        (isBankerOrAdmin() && 
         belongsToFamily(resource.data.familyId) &&
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['roles']));
      
      // Allow Bankers/Admins to update relationship field of other users in their family
      allow update: if isAuthenticated() && 
        request.auth.uid != userId &&
        isBankerOrAdmin() &&
        belongsToFamily(resource.data.familyId) &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['relationship']);
      
      // Ignored conflicts subcollection - users can manage their own ignored conflicts
      match /ignoredConflicts/{conflictKey} {
        allow read, write: if isAuthenticated() && request.auth.uid == userId;
      }
      
      // SMS conversations subcollection (premium feature)
      match /sms_conversations/{phoneNumber} {
        allow read, write: if isAuthenticated() && request.auth.uid == userId;
        
        // Messages subcollection
        match /messages/{messageId} {
          allow read, write: if isAuthenticated() && request.auth.uid == userId;
        }
      }
    }
    
    // Test users collection - same rules as users (for qa/test environment)
    match /test_users/{userId} {
      // Users can read their own document
      allow read: if isAuthenticated() && request.auth.uid == userId;
      
      // Users can read other users' documents (needed for family members list and invitation verification)
      allow read: if isAuthenticated();
      
      // Users can write their own document
      allow write: if isAuthenticated() && request.auth.uid == userId;
      
      // Allow Bankers/Admins to update roles field of other users in their family
      allow update: if isAuthenticated() && 
        request.auth.uid == userId ||
        (isBankerOrAdmin() && 
         belongsToFamily(resource.data.familyId) &&
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['roles']));
      
      // Allow Bankers/Admins to update relationship field of other users in their family
      allow update: if isAuthenticated() && 
        request.auth.uid != userId &&
        isBankerOrAdmin() &&
        belongsToFamily(resource.data.familyId) &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['relationship']);
      
      // Ignored conflicts subcollection - users can manage their own ignored conflicts
      match /ignoredConflicts/{conflictKey} {
        allow read, write: if isAuthenticated() && request.auth.uid == userId;
      }
    }
    
    // Family collections - tasks, events, messages, etc.
    match /families/{familyId} {
      // Allow read if user belongs to the family
      allow read: if belongsToFamily(familyId);
      
      // Allow creating family document if it doesn't exist (for first job creation)
      allow create: if belongsToFamily(familyId) &&
        request.resource.data.walletBalance is number;
      
      // Allow updating walletBalance field for family members (for job creation/approval)
      // This handles both updates to existing documents and set() with merge on new documents
      // Also allow admins to update openMatchmakingEnabled setting (deployed 2025-12-10, force update)
      allow update: if belongsToFamily(familyId) && (
        // Update walletBalance (existing rule)
        (request.resource.data.walletBalance is number &&
         (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['walletBalance']) ||
          !exists(/databases/$(database)/documents/families/$(familyId)))) ||
        // Update openMatchmakingEnabled (admin only)
        (isAdmin() &&
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['openMatchmakingEnabled']) &&
         request.resource.data.openMatchmakingEnabled is bool) ||
        // Allow set() with merge for both fields
        (!exists(/databases/$(database)/documents/families/$(familyId)) &&
         (request.resource.data.walletBalance is number || request.resource.data.openMatchmakingEnabled is bool))
      );
      
      // Tasks subcollection
      match /tasks/{taskId} {
        allow read: if belongsToFamily(familyId);
        allow create: if belongsToFamily(familyId) && 
          request.resource.data.createdBy == request.auth.uid;
        allow update: if belongsToFamily(familyId) && 
          (resource.data.createdBy == request.auth.uid ||
           resource.data.claimedBy == request.auth.uid ||
           resource.data.assignedTo == request.auth.uid ||
           // Allow any family member to complete tasks that don't require claim
           (resource.data.requiresClaim == false || !('requiresClaim' in resource.data)) ||
           // Allow any family member to claim a job (set claimedBy and claimStatus)
           // Permissive rule: allow if user is setting themselves as claimer
           (request.resource.data.claimedBy == request.auth.uid &&
            (request.resource.data.claimStatus == 'pending' ||
             request.resource.data.claimStatus == 'approved' ||
             request.resource.data.claimStatus == 'rejected' ||
             !('claimStatus' in request.resource.data))));
        allow delete: if belongsToFamily(familyId) && 
          (resource.data.createdBy == request.auth.uid ||
           // Allow admin to delete any job for cleanup/admin operations
           isAdmin());
        
        // Task dependencies subcollection
        match /dependencies/{dependencyId} {
          allow read: if belongsToFamily(familyId);
          allow create: if belongsToFamily(familyId);
          allow update: if belongsToFamily(familyId);
          allow delete: if belongsToFamily(familyId);
        }
      }
      
      // Calendar events subcollection
      match /events/{eventId} {
        allow read: if belongsToFamily(familyId);
        allow create: if belongsToFamily(familyId) && 
          request.resource.data.createdBy == request.auth.uid;
        // Allow any family member to update events (for collaboration and duplicate cleanup)
        // Ownership checks are handled at the application level
        allow update: if belongsToFamily(familyId);
        allow delete: if belongsToFamily(familyId) && 
          (resource.data.eventOwnerId == request.auth.uid ||
           resource.data.createdBy == request.auth.uid ||
           // Allow admin/banker to delete events for duplicate cleanup operations
           isBankerOrAdmin());
        
        // Event-specific chat messages subcollection
        match /chats/{messageId} {
          // Helper function to check if user has access to event chat
          // Access granted to: event creator + invitedMemberIds
          function hasEventChatAccess() {
            let eventData = get(/databases/$(database)/documents/families/$(familyId)/events/$(eventId)).data;
            let createdBy = eventData.createdBy;
            let invitedMemberIds = eventData.invitedMemberIds is list ? eventData.invitedMemberIds : [];
            return request.auth != null && 
              (createdBy == request.auth.uid || 
               request.auth.uid in invitedMemberIds);
          }
          
          // Helper function to check if user is Admin
          function isAdmin() {
            return isAuthenticated() && 
              userDocumentExists() &&
              get(/databases/$(database)/documents/users/$(request.auth.uid)).data.roles.hasAny(['Admin', 'admin']);
          }
          
          // Read: Only event creator + invited members
          allow read: if belongsToFamily(familyId) && hasEventChatAccess();
          
          // Create: Only event creator + invited members, and sender must be current user
          allow create: if belongsToFamily(familyId) && 
            hasEventChatAccess() &&
            request.resource.data.senderId == request.auth.uid;
          
          // Update: Only message sender can edit their own messages
          allow update: if belongsToFamily(familyId) && 
            hasEventChatAccess() &&
            resource.data.senderId == request.auth.uid;
          
          // Delete: Message sender OR admin can delete
          allow delete: if belongsToFamily(familyId) && 
            hasEventChatAccess() &&
            (resource.data.senderId == request.auth.uid || isAdmin());
        }
      }
      
      // Chat messages subcollection
      match /messages/{messageId} {
        allow read: if belongsToFamily(familyId);
        allow create: if belongsToFamily(familyId) && 
          request.resource.data.senderId == request.auth.uid;
        allow update: if belongsToFamily(familyId) && 
          resource.data.senderId == request.auth.uid;
        allow delete: if belongsToFamily(familyId) && 
          resource.data.senderId == request.auth.uid;
        
        // Message reactions subcollection
        match /reactions/{reactionId} {
          allow read: if belongsToFamily(familyId);
          allow create: if belongsToFamily(familyId) && 
            request.resource.data.userId == request.auth.uid;
          allow update: if belongsToFamily(familyId) && 
            resource.data.userId == request.auth.uid;
          allow delete: if belongsToFamily(familyId) && 
            resource.data.userId == request.auth.uid;
        }
        
        // Message replies subcollection (for threading)
        match /replies/{replyId} {
          allow read: if belongsToFamily(familyId);
          allow create: if belongsToFamily(familyId) && 
            request.resource.data.senderId == request.auth.uid;
          allow update: if belongsToFamily(familyId) && 
            resource.data.senderId == request.auth.uid;
          allow delete: if belongsToFamily(familyId) && 
            resource.data.senderId == request.auth.uid;
        }
      }
      
      // Private messages subcollection
      match /privateMessages/{chatId} {
        allow read: if belongsToFamily(familyId);
        allow create: if belongsToFamily(familyId);
        // Nested messages collection
        match /messages/{messageId} {
          allow read: if belongsToFamily(familyId);
          allow create: if belongsToFamily(familyId) && 
            request.resource.data.senderId == request.auth.uid;
          allow update: if belongsToFamily(familyId) && 
            resource.data.senderId == request.auth.uid;
          allow delete: if belongsToFamily(familyId) && 
            resource.data.senderId == request.auth.uid;
        }
        // Read status subcollection - users can write their own read status
        match /readStatus/{userId} {
          allow read: if belongsToFamily(familyId);
          allow write: if belongsToFamily(familyId) && 
            request.auth.uid == userId;
        }
      }
      
      // Family members location subcollection
      match /members/{memberId} {
        allow read: if belongsToFamily(familyId);
        allow write: if belongsToFamily(familyId) && 
          request.auth.uid == memberId;
      }
      
      // Game stats subcollection
      match /game_stats/{userId} {
        allow read: if belongsToFamily(familyId);
        // Allow create/update if document ID matches auth uid (user updating their own stats)
        // The document ID is the userId, so we check that directly
        allow create, update: if belongsToFamily(familyId) && 
          userId == request.auth.uid;
      }
      
      // Photo albums subcollection
      match /albums/{albumId} {
        allow read: if belongsToFamily(familyId);
        allow create: if belongsToFamily(familyId) && 
          request.resource.data.createdBy == request.auth.uid;
        allow update: if belongsToFamily(familyId) && 
          (resource.data.createdBy == request.auth.uid ||
           request.resource.data.diff(resource.data).affectedKeys().hasOnly(['coverPhotoId', 'photoCount', 'lastPhotoAddedAt']));
        allow delete: if belongsToFamily(familyId) && 
          resource.data.createdBy == request.auth.uid;
      }
      
      // Photos subcollection
      match /photos/{photoId} {
        allow read: if belongsToFamily(familyId);
        allow create: if belongsToFamily(familyId) && 
          request.resource.data.uploadedBy == request.auth.uid;
        allow update: if belongsToFamily(familyId) && 
          (resource.data.uploadedBy == request.auth.uid ||
           request.resource.data.diff(resource.data).affectedKeys().hasOnly(['viewCount', 'lastViewedAt']));
        allow delete: if belongsToFamily(familyId) && 
          resource.data.uploadedBy == request.auth.uid;
        
        // Photo comments subcollection
        match /comments/{commentId} {
          allow read: if belongsToFamily(familyId);
          allow create: if belongsToFamily(familyId) && 
            request.resource.data.authorId == request.auth.uid;
          allow update: if belongsToFamily(familyId) && 
            resource.data.authorId == request.auth.uid;
          allow delete: if belongsToFamily(familyId) && 
            resource.data.authorId == request.auth.uid;
        }
      }
      
      // Payout requests subcollection
      match /payoutRequests/{requestId} {
        allow create: if belongsToFamily(familyId) && 
          request.resource.data.userId == request.auth.uid &&
          request.resource.data.status == 'pending' &&
          request.resource.data.amount is number &&
          request.resource.data.amount > 0;
        allow read: if belongsToFamily(familyId) && 
          (resource.data.userId == request.auth.uid || isBankerOrAdmin());
        allow update: if belongsToFamily(familyId) && 
          isBankerOrAdmin() &&
          resource.data.userId == request.resource.data.userId &&
          resource.data.amount == request.resource.data.amount;
        allow delete: if false; // No delete (keep for history)
      }
      
      // Approved payouts subcollection
      match /payouts/{payoutId} {
        allow create: if belongsToFamily(familyId) && isBankerOrAdmin() &&
          request.resource.data.userId is string &&
          request.resource.data.amount is number &&
          request.resource.data.amount > 0;
        allow read: if belongsToFamily(familyId) && 
          (resource.data.userId == request.auth.uid || isBankerOrAdmin());
        allow update: if false; // Immutable records
        allow delete: if false; // Immutable records
      }
      
      // Recurring payments subcollection
      match /recurringPayments/{paymentId} {
        allow create: if belongsToFamily(familyId) && isBankerOrAdmin() &&
          request.resource.data.fromUserId == request.auth.uid &&
          request.resource.data.toUserId is string &&
          request.resource.data.amount is number &&
          request.resource.data.amount > 0 &&
          request.resource.data.frequency in ['weekly', 'monthly'] &&
          request.resource.data.isActive == true;
        allow read: if belongsToFamily(familyId) && 
          (resource.data.toUserId == request.auth.uid || 
           resource.data.fromUserId == request.auth.uid ||
           isBankerOrAdmin());
        allow update: if belongsToFamily(familyId) && isBankerOrAdmin() &&
          resource.data.fromUserId == request.resource.data.fromUserId &&
          resource.data.toUserId == request.resource.data.toUserId &&
          resource.data.amount == request.resource.data.amount &&
          resource.data.frequency == request.resource.data.frequency;
        allow delete: if false; // Keep for history
      }
      
      // Pocket money payments subcollection
      match /pocketMoneyPayments/{paymentRecordId} {
        allow create: if belongsToFamily(familyId) && isBankerOrAdmin() &&
          request.resource.data.fromUserId is string &&
          request.resource.data.toUserId is string &&
          request.resource.data.amount is number &&
          request.resource.data.amount > 0;
        allow read: if belongsToFamily(familyId) && 
          (resource.data.toUserId == request.auth.uid || 
           resource.data.fromUserId == request.auth.uid ||
           isBankerOrAdmin());
        allow update: if false; // Immutable records
        allow delete: if false; // Immutable records
      }
      
      // Family wallet document
      match /wallet/{walletId} {
        allow read: if belongsToFamily(familyId);
        allow write: if belongsToFamily(familyId) && isBankerOrAdmin();
      }
      
      // Notifications subcollection
      match /notifications/{notificationId} {
        allow read: if belongsToFamily(familyId) && 
          resource.data.userId == request.auth.uid;
        allow create: if belongsToFamily(familyId);
        allow update: if belongsToFamily(familyId) && 
          resource.data.userId == request.auth.uid;
        allow delete: if belongsToFamily(familyId) && 
          resource.data.userId == request.auth.uid;
      }
      
      // Hubs subcollection
      match /hubs/{hubId} {
        allow read: if belongsToFamily(familyId);
        allow create: if belongsToFamily(familyId) && 
          request.resource.data.creatorId == request.auth.uid;
        allow update: if belongsToFamily(familyId) && 
          (resource.data.creatorId == request.auth.uid ||
           resource.data.memberIds.hasAny([request.auth.uid]));
        allow delete: if belongsToFamily(familyId) && 
          resource.data.creatorId == request.auth.uid;
      }
      
      // Hub invites subcollection
      match /hubInvites/{inviteId} {
        allow read: if belongsToFamily(familyId);
        allow create: if belongsToFamily(familyId);
        allow update: if belongsToFamily(familyId);
        allow delete: if belongsToFamily(familyId);
      }
      
      // Event templates subcollection
      match /eventTemplates/{templateId} {
        allow read: if belongsToFamily(familyId);
        allow create: if belongsToFamily(familyId) && 
          request.resource.data.createdBy == request.auth.uid;
        allow update: if belongsToFamily(familyId) && 
          resource.data.createdBy == request.auth.uid;
        allow delete: if belongsToFamily(familyId) && 
          resource.data.createdBy == request.auth.uid;
      }
      
      // Shopping categories subcollection
      match /shoppingCategories/{categoryId} {
        allow read: if belongsToFamily(familyId);
        allow create: if belongsToFamily(familyId);
        allow update: if belongsToFamily(familyId);
        allow delete: if belongsToFamily(familyId);
      }
      
      // Shopping lists subcollection
      match /shoppingLists/{listId} {
        allow read: if belongsToFamily(familyId);
        allow create: if belongsToFamily(familyId) && 
          request.resource.data.creatorId == request.auth.uid;
        allow update: if belongsToFamily(familyId);
        allow delete: if belongsToFamily(familyId);
        
        // Shopping items subcollection
        match /items/{itemId} {
          allow read: if belongsToFamily(familyId);
          allow create: if belongsToFamily(familyId);
          allow update: if belongsToFamily(familyId);
          allow delete: if belongsToFamily(familyId);
        }
      }
      
      // Smart recurring lists subcollection
      match /smartRecurringLists/{listId} {
        allow read: if belongsToFamily(familyId);
        allow create: if belongsToFamily(familyId);
        allow update: if belongsToFamily(familyId);
        allow delete: if belongsToFamily(familyId);
      }
      
      // Shopping receipts subcollection
      match /shoppingReceipts/{receiptId} {
        allow read: if belongsToFamily(familyId);
        allow create: if belongsToFamily(familyId);
        allow update: if belongsToFamily(familyId);
        allow delete: if belongsToFamily(familyId);
      }
      
      // Location requests subcollection
      match /locationRequests/{requestId} {
        allow read: if belongsToFamily(familyId);
        allow create: if belongsToFamily(familyId);
        allow update: if belongsToFamily(familyId);
        allow delete: if belongsToFamily(familyId);
      }
      
      // Budgets subcollection
      match /budgets/{budgetId} {
        allow read: if belongsToFamily(familyId);
        allow create: if belongsToFamily(familyId) && 
          request.resource.data.createdBy == request.auth.uid;
        allow update: if belongsToFamily(familyId) && 
          (resource.data.createdBy == request.auth.uid ||
           isBankerOrAdmin());
        allow delete: if belongsToFamily(familyId) && 
          (resource.data.createdBy == request.auth.uid ||
           isBankerOrAdmin());
        
        // Budget categories subcollection
        match /categories/{categoryId} {
          allow read: if belongsToFamily(familyId);
          allow create: if belongsToFamily(familyId);
          allow update: if belongsToFamily(familyId);
          allow delete: if belongsToFamily(familyId);
        }
        
        // Budget items subcollection
        match /items/{itemId} {
          allow read: if belongsToFamily(familyId);
          allow create: if belongsToFamily(familyId) && 
            request.resource.data.createdBy == request.auth.uid;
          allow update: if belongsToFamily(familyId) && 
            (resource.data.createdBy == request.auth.uid ||
             isBankerOrAdmin());
          allow delete: if belongsToFamily(familyId) && 
            (resource.data.createdBy == request.auth.uid ||
             isBankerOrAdmin());
        }
        
        // Budget transactions subcollection
        match /transactions/{transactionId} {
          allow read: if belongsToFamily(familyId);
          allow create: if belongsToFamily(familyId) && 
            request.resource.data.createdBy == request.auth.uid &&
            request.resource.data.itemId != null; // Require itemId
          allow update: if belongsToFamily(familyId) && 
            (resource.data.createdBy == request.auth.uid ||
             isBankerOrAdmin());
          allow delete: if belongsToFamily(familyId) && 
            (resource.data.createdBy == request.auth.uid ||
             isBankerOrAdmin());
        }
        
        // Savings goals subcollection
        match /savingsGoals/{goalId} {
          allow read: if belongsToFamily(familyId);
          allow create: if belongsToFamily(familyId) && 
            request.resource.data.createdBy == request.auth.uid;
          allow update: if belongsToFamily(familyId) && 
            (resource.data.createdBy == request.auth.uid ||
             isBankerOrAdmin());
          allow delete: if belongsToFamily(familyId) && 
            (resource.data.createdBy == request.auth.uid ||
             isBankerOrAdmin());
        }
      }
    }
    
    // Dev families collection - same rules as families (for dev environment)
    match /dev_families/{familyId} {
      // Allow read if user belongs to the family
      allow read: if belongsToFamily(familyId);
      
      // Allow creating family document if it doesn't exist (for first job creation)
      allow create: if belongsToFamily(familyId) &&
        request.resource.data.walletBalance is number;
      
      // Allow updating walletBalance field for family members (for job creation/approval)
      // This handles both updates to existing documents and set() with merge on new documents
      // Also allow admins to update openMatchmakingEnabled setting
      allow update: if belongsToFamily(familyId) && (
        // Update walletBalance (existing rule)
        (request.resource.data.walletBalance is number &&
         (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['walletBalance']) ||
          !exists(/databases/$(database)/documents/dev_families/$(familyId)))) ||
        // Update openMatchmakingEnabled (admin only)
        (isAdmin() &&
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['openMatchmakingEnabled']) &&
         request.resource.data.openMatchmakingEnabled is bool) ||
        // Allow set() with merge for both fields
        (!exists(/databases/$(database)/documents/dev_families/$(familyId)) &&
         (request.resource.data.walletBalance is number || request.resource.data.openMatchmakingEnabled is bool))
      );
      
      // All subcollections follow same pattern as families - delegate to a helper or duplicate structure
      // For now, allow all authenticated family members (same as families)
      match /{document=**} {
        allow read, write: if belongsToFamily(familyId);
      }
    }
    
    // Test families collection - same rules as families (for qa/test environment)
    match /test_families/{familyId} {
      // Allow read if user belongs to the family
      allow read: if belongsToFamily(familyId);
      
      // Allow creating family document if it doesn't exist (for first job creation)
      allow create: if belongsToFamily(familyId) &&
        request.resource.data.walletBalance is number;
      
      // Allow updating walletBalance field for family members (for job creation/approval)
      // This handles both updates to existing documents and set() with merge on new documents
      // Also allow admins to update openMatchmakingEnabled setting
      allow update: if belongsToFamily(familyId) && (
        // Update walletBalance (existing rule)
        (request.resource.data.walletBalance is number &&
         (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['walletBalance']) ||
          !exists(/databases/$(database)/documents/test_families/$(familyId)))) ||
        // Update openMatchmakingEnabled (admin only)
        (isAdmin() &&
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['openMatchmakingEnabled']) &&
         request.resource.data.openMatchmakingEnabled is bool) ||
        // Allow set() with merge for both fields
        (!exists(/databases/$(database)/documents/test_families/$(familyId)) &&
         (request.resource.data.walletBalance is number || request.resource.data.openMatchmakingEnabled is bool))
      );
      
      // All subcollections follow same pattern as families - delegate to a helper or duplicate structure
      // For now, allow all authenticated family members (same as families)
      match /{document=**} {
        allow read, write: if belongsToFamily(familyId);
      }
    }
    
    // Notifications collection (top-level, for backward compatibility)
    match /notifications/{notificationId} {
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow create: if isAuthenticated();
      allow update: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }
    
    // Hubs collection (top-level, for backward compatibility)
    match /hubs/{hubId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && request.resource.data.creatorId == request.auth.uid;
      allow update: if isAuthenticated() && 
        (resource.data.creatorId == request.auth.uid ||
         resource.data.memberIds.hasAny([request.auth.uid]));
      allow delete: if isAuthenticated() && resource.data.creatorId == request.auth.uid;
      
      // Helper function to check if user is a hub member
      function isHubMember() {
        return isAuthenticated() && 
          (exists(/databases/$(database)/documents/hubs/$(hubId)) &&
           (get(/databases/$(database)/documents/hubs/$(hubId)).data.creatorId == request.auth.uid ||
            request.auth.uid in get(/databases/$(database)/documents/hubs/$(hubId)).data.memberIds));
      }
      
      // Hub messages subcollection
      match /messages/{messageId} {
        allow read: if isHubMember();
        allow create: if isHubMember() && 
          request.resource.data.senderId == request.auth.uid;
        allow update: if isHubMember() && 
          resource.data.senderId == request.auth.uid;
        allow delete: if isHubMember() && 
          resource.data.senderId == request.auth.uid;
      }
      
      // Assignments (homeschooling)
      match /assignments/{assignmentId} {
        allow read: if isHubMember();
        allow create: if isHubMember() && request.auth.uid == request.resource.data.createdBy;
        allow update: if isHubMember() && 
          (request.auth.uid == resource.data.createdBy || 
           request.auth.uid == resource.data.studentId);
        allow delete: if isHubMember() && request.auth.uid == resource.data.createdBy;
      }
      
      // Lesson plans (homeschooling)
      match /lessonPlans/{planId} {
        allow read: if isHubMember();
        allow create: if isHubMember() && request.auth.uid == request.resource.data.createdBy;
        allow update: if isHubMember() && request.auth.uid == resource.data.createdBy;
        allow delete: if isHubMember() && request.auth.uid == resource.data.createdBy;
      }
      
      // Student profiles (homeschooling)
      match /student_profiles/{profileId} {
        allow read: if isHubMember();
        allow create: if isHubMember() && 
          request.auth.uid == request.resource.data.createdBy &&
          request.resource.data.hubId == hubId;
        allow update: if isHubMember() && 
          request.auth.uid == resource.data.createdBy &&
          resource.data.hubId == hubId;
        allow delete: if isHubMember() && 
          request.auth.uid == resource.data.createdBy &&
          resource.data.hubId == hubId;
      }
      
      // Educational resources (homeschooling)
      match /educational_resources/{resourceId} {
        allow read: if isHubMember();
        allow create: if isHubMember() &&
          request.auth.uid == request.resource.data.createdBy &&
          request.resource.data.hubId == hubId;
        allow update: if isHubMember() &&
          request.auth.uid == resource.data.createdBy &&
          resource.data.hubId == hubId;
        allow delete: if isHubMember() &&
          request.auth.uid == resource.data.createdBy &&
          resource.data.hubId == hubId;
      }
      
      // Progress reports (homeschooling)
      match /progress_reports/{reportId} {
        allow read: if isHubMember();
        allow create: if isHubMember() &&
          request.auth.uid == request.resource.data.createdBy &&
          request.resource.data.hubId == hubId;
        allow update: if isHubMember() &&
          request.auth.uid == resource.data.createdBy &&
          resource.data.hubId == hubId;
        allow delete: if isHubMember() &&
          request.auth.uid == resource.data.createdBy &&
          resource.data.hubId == hubId;
      }
      
      // Learning milestones (homeschooling)
      match /learning_milestones/{milestoneId} {
        allow read: if isHubMember();
        allow create: if isHubMember() &&
          request.resource.data.hubId == hubId;
        allow update: if isHubMember() &&
          resource.data.hubId == hubId;
        allow delete: if isHubMember() &&
          resource.data.hubId == hubId;
      }
      
      // Custody schedules (co-parenting)
      match /custodySchedules/{scheduleId} {
        allow read: if isHubMember();
        allow create: if isHubMember() && request.auth.uid == request.resource.data.createdBy;
        allow update: if isHubMember() && request.auth.uid == resource.data.createdBy;
        allow delete: if isHubMember() && request.auth.uid == resource.data.createdBy;
      }
      
      // Schedule change requests (co-parenting)
      match /scheduleChangeRequests/{requestId} {
        allow read: if isHubMember();
        allow create: if isHubMember() && request.auth.uid == request.resource.data.requestedBy;
        allow update: if isHubMember() && 
          (request.auth.uid == resource.data.requestedBy || 
           request.auth.uid == resource.data.respondedBy);
      }
      
      // Co-parenting expenses
      match /expenses/{expenseId} {
        allow read: if isHubMember();
        allow create: if isHubMember() && request.auth.uid == request.resource.data.createdBy;
        allow update: if isHubMember() && 
          (request.auth.uid == resource.data.createdBy || 
           request.auth.uid == resource.data.paidBy);
      }
      
      // Message templates (co-parenting)
      match /message_templates/{templateId} {
        allow read: if isHubMember();
        allow create: if isHubMember() &&
          request.auth.uid == request.resource.data.createdBy &&
          request.resource.data.hubId == hubId;
        allow update: if isHubMember() &&
          request.auth.uid == resource.data.createdBy &&
          resource.data.hubId == hubId;
        allow delete: if isHubMember() &&
          request.auth.uid == resource.data.createdBy &&
          resource.data.hubId == hubId;
      }
      
      // Child profiles (co-parenting)
      match /child_profiles/{profileId} {
        allow read: if isHubMember();
        allow create: if isHubMember() &&
          request.auth.uid == request.resource.data.createdBy &&
          request.resource.data.hubId == hubId;
        allow update: if isHubMember() &&
          request.resource.data.hubId == hubId;
        allow delete: if isHubMember() &&
          request.resource.data.hubId == hubId;
      }
      
      // Books (library hub)
      match /books/{bookId} {
        allow read: if isHubMember();
        allow create: if isHubMember();
        allow update: if isHubMember();
        allow delete: if isHubMember();
        
        // Book ratings subcollection
        match /ratings/{ratingId} {
          allow read: if isHubMember();
          allow create: if isHubMember() &&
            request.auth.uid == request.resource.data.userId;
          allow update: if isHubMember() &&
            request.auth.uid == resource.data.userId;
          allow delete: if isHubMember() &&
            request.auth.uid == resource.data.userId;
        }
        
        // Book quizzes subcollection
        match /quizzes/{quizId} {
          allow read: if isHubMember();
          allow create: if isHubMember() &&
            request.auth.uid == request.resource.data.userId;
          allow update: if isHubMember() &&
            request.auth.uid == resource.data.userId;
        }
        
        // User-uploaded book files subcollection
        match /uploads/{uploadId} {
          allow read: if isHubMember();
          allow create: if isHubMember() &&
            request.auth.uid == request.resource.data.uploadedBy;
          allow update: if isHubMember() &&
            request.auth.uid == resource.data.uploadedBy;
          allow delete: if isHubMember() &&
            request.auth.uid == resource.data.uploadedBy;
        }
      }
      
      // Exploding Books challenges
      match /exploding_books/{challengeId} {
        allow read: if isHubMember();
        allow create: if isHubMember() &&
          request.auth.uid == request.resource.data.userId &&
          request.resource.data.hubId == hubId;
        allow update: if isHubMember() &&
          request.auth.uid == resource.data.userId &&
          resource.data.hubId == hubId;
        allow delete: if isHubMember() &&
          request.auth.uid == resource.data.userId;
      }
      
      // Leaderboards
      match /leaderboards/exploding_books/entries/{entryId} {
        allow read: if isHubMember();
        // Write only by service account (via Cloud Functions)
        allow write: if false;
      }
    }
    
    // Dev hubs collection (for dev environment)
    match /dev_hubs/{hubId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && request.resource.data.creatorId == request.auth.uid;
      allow update: if isAuthenticated() && 
        (resource.data.creatorId == request.auth.uid ||
         resource.data.memberIds.hasAny([request.auth.uid]));
      allow delete: if isAuthenticated() && resource.data.creatorId == request.auth.uid;
      
      // Helper function to check if user is a hub member
      // Checks both prefixed (dev_hubs) and unprefixed (hubs) collections
      function isHubMember() {
        return isAuthenticated() && (
          // Check dev_hubs collection
          (exists(/databases/$(database)/documents/dev_hubs/$(hubId)) &&
           (get(/databases/$(database)/documents/dev_hubs/$(hubId)).data.creatorId == request.auth.uid ||
            request.auth.uid in get(/databases/$(database)/documents/dev_hubs/$(hubId)).data.memberIds)) ||
          // Fallback to hubs collection (for backwards compatibility)
          (exists(/databases/$(database)/documents/hubs/$(hubId)) &&
           (get(/databases/$(database)/documents/hubs/$(hubId)).data.creatorId == request.auth.uid ||
            request.auth.uid in get(/databases/$(database)/documents/hubs/$(hubId)).data.memberIds))
        );
      }
      
      // Hub messages subcollection
      match /messages/{messageId} {
        allow read: if isHubMember();
        allow create: if isHubMember() && 
          request.resource.data.senderId == request.auth.uid;
        allow update: if isHubMember() && 
          resource.data.senderId == request.auth.uid;
        allow delete: if isHubMember() && 
          resource.data.senderId == request.auth.uid;
      }
      
      // Assignments (homeschooling)
      match /assignments/{assignmentId} {
        allow read: if isHubMember();
        allow create: if isHubMember() && request.auth.uid == request.resource.data.createdBy;
        allow update: if isHubMember() && 
          (request.auth.uid == resource.data.createdBy || 
           request.auth.uid == resource.data.studentId);
        allow delete: if isHubMember() && request.auth.uid == resource.data.createdBy;
      }
      
      // Lesson plans (homeschooling)
      match /lessonPlans/{planId} {
        allow read: if isHubMember();
        allow create: if isHubMember() && request.auth.uid == request.resource.data.createdBy;
        allow update: if isHubMember() && request.auth.uid == resource.data.createdBy;
        allow delete: if isHubMember() && request.auth.uid == resource.data.createdBy;
      }
      
      // Student profiles (homeschooling)
      match /student_profiles/{profileId} {
        allow read: if isHubMember();
        allow create: if isHubMember() && 
          request.auth.uid == request.resource.data.createdBy &&
          request.resource.data.hubId == hubId;
        allow update: if isHubMember() && 
          request.auth.uid == resource.data.createdBy &&
          resource.data.hubId == hubId;
        allow delete: if isHubMember() && 
          request.auth.uid == resource.data.createdBy &&
          resource.data.hubId == hubId;
      }
      
      // Educational resources (homeschooling)
      match /educational_resources/{resourceId} {
        allow read: if isHubMember();
        allow create: if isHubMember() &&
          request.auth.uid == request.resource.data.createdBy &&
          request.resource.data.hubId == hubId;
        allow update: if isHubMember() &&
          request.auth.uid == resource.data.createdBy &&
          resource.data.hubId == hubId;
        allow delete: if isHubMember() &&
          request.auth.uid == resource.data.createdBy &&
          resource.data.hubId == hubId;
      }
      
      // Progress reports (homeschooling)
      match /progress_reports/{reportId} {
        allow read: if isHubMember();
        allow create: if isHubMember() &&
          request.auth.uid == request.resource.data.createdBy &&
          request.resource.data.hubId == hubId;
        allow update: if isHubMember() &&
          request.auth.uid == resource.data.createdBy &&
          resource.data.hubId == hubId;
        allow delete: if isHubMember() &&
          request.auth.uid == resource.data.createdBy &&
          resource.data.hubId == hubId;
      }
      
      // Learning milestones (homeschooling)
      match /learning_milestones/{milestoneId} {
        allow read: if isHubMember();
        allow create: if isHubMember() &&
          request.resource.data.hubId == hubId;
        allow update: if isHubMember() &&
          resource.data.hubId == hubId;
        allow delete: if isHubMember() &&
          resource.data.hubId == hubId;
      }
      
      // Custody schedules (co-parenting)
      match /custodySchedules/{scheduleId} {
        allow read: if isHubMember();
        allow create: if isHubMember() && request.auth.uid == request.resource.data.createdBy;
        allow update: if isHubMember() && request.auth.uid == resource.data.createdBy;
        allow delete: if isHubMember() && request.auth.uid == resource.data.createdBy;
      }
      
      // Schedule change requests (co-parenting)
      match /scheduleChangeRequests/{requestId} {
        allow read: if isHubMember();
        allow create: if isHubMember() && request.auth.uid == request.resource.data.requestedBy;
        allow update: if isHubMember() && 
          (request.auth.uid == resource.data.requestedBy || 
           request.auth.uid == resource.data.respondedBy);
      }
      
      // Co-parenting expenses
      match /expenses/{expenseId} {
        allow read: if isHubMember();
        allow create: if isHubMember() && request.auth.uid == request.resource.data.createdBy;
        allow update: if isHubMember() && 
          (request.auth.uid == resource.data.createdBy || 
           request.auth.uid == resource.data.paidBy);
      }
      
      // Message templates (co-parenting)
      match /message_templates/{templateId} {
        allow read: if isHubMember();
        allow create: if isHubMember() &&
          request.auth.uid == request.resource.data.createdBy &&
          request.resource.data.hubId == hubId;
        allow update: if isHubMember() &&
          request.auth.uid == resource.data.createdBy &&
          resource.data.hubId == hubId;
        allow delete: if isHubMember() &&
          request.auth.uid == resource.data.createdBy &&
          resource.data.hubId == hubId;
      }
      
      // Child profiles (co-parenting)
      match /child_profiles/{profileId} {
        allow read: if isHubMember();
        allow create: if isHubMember() &&
          request.auth.uid == request.resource.data.createdBy &&
          request.resource.data.hubId == hubId;
        allow update: if isHubMember() &&
          request.resource.data.hubId == hubId;
        allow delete: if isHubMember() &&
          request.resource.data.hubId == hubId;
      }
      
      // Books (library hub)
      match /books/{bookId} {
        allow read: if isHubMember();
        allow create: if isHubMember();
        allow update: if isHubMember();
        allow delete: if isHubMember();
        
        // Book ratings subcollection
        match /ratings/{ratingId} {
          allow read: if isHubMember();
          allow create: if isHubMember() &&
            request.auth.uid == request.resource.data.userId;
          allow update: if isHubMember() &&
            request.auth.uid == resource.data.userId;
          allow delete: if isHubMember() &&
            request.auth.uid == resource.data.userId;
        }
        
        // Book quizzes subcollection
        match /quizzes/{quizId} {
          allow read: if isHubMember();
          allow create: if isHubMember() &&
            request.auth.uid == request.resource.data.userId;
          allow update: if isHubMember() &&
            request.auth.uid == resource.data.userId;
        }
        
        // User-uploaded book files subcollection
        match /uploads/{uploadId} {
          allow read: if isHubMember();
          allow create: if isHubMember() &&
            request.auth.uid == request.resource.data.uploadedBy;
          allow update: if isHubMember() &&
            request.auth.uid == resource.data.uploadedBy;
          allow delete: if isHubMember() &&
            request.auth.uid == resource.data.uploadedBy;
        }
      }
      
      // Exploding Books challenges
      match /exploding_books/{challengeId} {
        allow read: if isHubMember();
        allow create: if isHubMember() &&
          request.auth.uid == request.resource.data.userId &&
          request.resource.data.hubId == hubId;
        allow update: if isHubMember() &&
          request.auth.uid == resource.data.userId &&
          resource.data.hubId == hubId;
        allow delete: if isHubMember() &&
          request.auth.uid == resource.data.userId;
      }
      
      // Leaderboards
      match /leaderboards/exploding_books/entries/{entryId} {
        allow read: if isHubMember();
        // Write only by service account (via Cloud Functions)
        allow write: if false;
      }
    }
    
    // Test hubs collection (for qa/test environment)
    match /test_hubs/{hubId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && request.resource.data.creatorId == request.auth.uid;
      allow update: if isAuthenticated() && 
        (resource.data.creatorId == request.auth.uid ||
         resource.data.memberIds.hasAny([request.auth.uid]));
      allow delete: if isAuthenticated() && resource.data.creatorId == request.auth.uid;
      
      // Helper function to check if user is a hub member
      function isHubMember() {
        return isAuthenticated() && 
          (exists(/databases/$(database)/documents/test_hubs/$(hubId)) &&
           (get(/databases/$(database)/documents/test_hubs/$(hubId)).data.creatorId == request.auth.uid ||
            request.auth.uid in get(/databases/$(database)/documents/test_hubs/$(hubId)).data.memberIds));
      }
      
      // Hub messages subcollection
      match /messages/{messageId} {
        allow read: if isHubMember();
        allow create: if isHubMember() && 
          request.resource.data.senderId == request.auth.uid;
        allow update: if isHubMember() && 
          resource.data.senderId == request.auth.uid;
        allow delete: if isHubMember() && 
          resource.data.senderId == request.auth.uid;
      }
      
      // Assignments (homeschooling)
      match /assignments/{assignmentId} {
        allow read: if isHubMember();
        allow create: if isHubMember() && request.auth.uid == request.resource.data.createdBy;
        allow update: if isHubMember() && 
          (request.auth.uid == resource.data.createdBy || 
           request.auth.uid == resource.data.studentId);
        allow delete: if isHubMember() && request.auth.uid == resource.data.createdBy;
      }
      
      // Lesson plans (homeschooling)
      match /lessonPlans/{planId} {
        allow read: if isHubMember();
        allow create: if isHubMember() && request.auth.uid == request.resource.data.createdBy;
        allow update: if isHubMember() && request.auth.uid == resource.data.createdBy;
        allow delete: if isHubMember() && request.auth.uid == resource.data.createdBy;
      }
      
      // Student profiles (homeschooling)
      match /student_profiles/{profileId} {
        allow read: if isHubMember();
        allow create: if isHubMember() && 
          request.auth.uid == request.resource.data.createdBy &&
          request.resource.data.hubId == hubId;
        allow update: if isHubMember() && 
          request.auth.uid == resource.data.createdBy &&
          resource.data.hubId == hubId;
        allow delete: if isHubMember() && 
          request.auth.uid == resource.data.createdBy &&
          resource.data.hubId == hubId;
      }
      
      // Educational resources (homeschooling)
      match /educational_resources/{resourceId} {
        allow read: if isHubMember();
        allow create: if isHubMember() &&
          request.auth.uid == request.resource.data.createdBy &&
          request.resource.data.hubId == hubId;
        allow update: if isHubMember() &&
          request.auth.uid == resource.data.createdBy &&
          resource.data.hubId == hubId;
        allow delete: if isHubMember() &&
          request.auth.uid == resource.data.createdBy &&
          resource.data.hubId == hubId;
      }
      
      // Progress reports (homeschooling)
      match /progress_reports/{reportId} {
        allow read: if isHubMember();
        allow create: if isHubMember() &&
          request.auth.uid == request.resource.data.createdBy &&
          request.resource.data.hubId == hubId;
        allow update: if isHubMember() &&
          request.auth.uid == resource.data.createdBy &&
          resource.data.hubId == hubId;
        allow delete: if isHubMember() &&
          request.auth.uid == resource.data.createdBy &&
          resource.data.hubId == hubId;
      }
      
      // Learning milestones (homeschooling)
      match /learning_milestones/{milestoneId} {
        allow read: if isHubMember();
        allow create: if isHubMember() &&
          request.resource.data.hubId == hubId;
        allow update: if isHubMember() &&
          resource.data.hubId == hubId;
        allow delete: if isHubMember() &&
          resource.data.hubId == hubId;
      }
      
      // Custody schedules (co-parenting)
      match /custodySchedules/{scheduleId} {
        allow read: if isHubMember();
        allow create: if isHubMember() && request.auth.uid == request.resource.data.createdBy;
        allow update: if isHubMember() && request.auth.uid == resource.data.createdBy;
        allow delete: if isHubMember() && request.auth.uid == resource.data.createdBy;
      }
      
      // Schedule change requests (co-parenting)
      match /scheduleChangeRequests/{requestId} {
        allow read: if isHubMember();
        allow create: if isHubMember() && request.auth.uid == request.resource.data.requestedBy;
        allow update: if isHubMember() && 
          (request.auth.uid == resource.data.requestedBy || 
           request.auth.uid == resource.data.respondedBy);
      }
      
      // Co-parenting expenses
      match /expenses/{expenseId} {
        allow read: if isHubMember();
        allow create: if isHubMember() && request.auth.uid == request.resource.data.createdBy;
        allow update: if isHubMember() && 
          (request.auth.uid == resource.data.createdBy || 
           request.auth.uid == resource.data.paidBy);
      }
      
      // Message templates (co-parenting)
      match /message_templates/{templateId} {
        allow read: if isHubMember();
        allow create: if isHubMember() &&
          request.auth.uid == request.resource.data.createdBy &&
          request.resource.data.hubId == hubId;
        allow update: if isHubMember() &&
          request.auth.uid == resource.data.createdBy &&
          resource.data.hubId == hubId;
        allow delete: if isHubMember() &&
          request.auth.uid == resource.data.createdBy &&
          resource.data.hubId == hubId;
      }
      
      // Child profiles (co-parenting)
      match /child_profiles/{profileId} {
        allow read: if isHubMember();
        allow create: if isHubMember() &&
          request.auth.uid == request.resource.data.createdBy &&
          request.resource.data.hubId == hubId;
        allow update: if isHubMember() &&
          request.resource.data.hubId == hubId;
        allow delete: if isHubMember() &&
          request.resource.data.hubId == hubId;
      }
      
      // Books (library hub)
      match /books/{bookId} {
        allow read: if isHubMember();
        allow create: if isHubMember();
        allow update: if isHubMember();
        allow delete: if isHubMember();
        
        // Book ratings subcollection
        match /ratings/{ratingId} {
          allow read: if isHubMember();
          allow create: if isHubMember() &&
            request.auth.uid == request.resource.data.userId;
          allow update: if isHubMember() &&
            request.auth.uid == resource.data.userId;
          allow delete: if isHubMember() &&
            request.auth.uid == resource.data.userId;
        }
        
        // Book quizzes subcollection
        match /quizzes/{quizId} {
          allow read: if isHubMember();
          allow create: if isHubMember() &&
            request.auth.uid == request.resource.data.userId;
          allow update: if isHubMember() &&
            request.auth.uid == resource.data.userId;
        }
        
        // User-uploaded book files subcollection
        match /uploads/{uploadId} {
          allow read: if isHubMember();
          allow create: if isHubMember() &&
            request.auth.uid == request.resource.data.uploadedBy;
          allow update: if isHubMember() &&
            request.auth.uid == resource.data.uploadedBy;
          allow delete: if isHubMember() &&
            request.auth.uid == resource.data.uploadedBy;
        }
      }
      
      // Exploding Books challenges
      match /exploding_books/{challengeId} {
        allow read: if isHubMember();
        allow create: if isHubMember() &&
          request.auth.uid == request.resource.data.userId &&
          request.resource.data.hubId == hubId;
        allow update: if isHubMember() &&
          request.auth.uid == resource.data.userId &&
          resource.data.hubId == hubId;
        allow delete: if isHubMember() &&
          request.auth.uid == resource.data.userId;
      }
      
      // Leaderboards
      match /leaderboards/exploding_books/entries/{entryId} {
        allow read: if isHubMember();
        // Write only by service account (via Cloud Functions)
        allow write: if false;
      }
    }
    
    // Hub invites collection (top-level, for backward compatibility)
    match /hubInvites/{inviteId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated();
      allow update: if isAuthenticated();
      allow delete: if isAuthenticated();
    }
    
    // Privacy activity collection
    match /privacy_activity/{activityId} {
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
    }
    
    // Video calls collection
    match /calls/{hubId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated();
      allow update: if isAuthenticated();
      allow delete: if isAuthenticated();
    }
    
    // Chess games collection
    match /chess_games/{gameId} {
      // Helper function to check if user is involved in the game
      function isGameParticipant() {
        return resource.data.whitePlayerId == request.auth.uid ||
               resource.data.blackPlayerId == request.auth.uid ||
               (resource.data.invitedPlayerId != null && 
                resource.data.invitedPlayerId == request.auth.uid) ||
               request.auth.uid in resource.data.spectators;
      }
      
      // CRITICAL FIX: Allow authenticated users to read ALL chess games
      // This is needed for:
      // 1. Collection queries (.get()) to fetch all games for deletion
      // 2. Stream queries to see waiting/active games
      // Individual document access is still controlled by isGameParticipant() for security
      // But collection-level queries need broader permission
      allow read: if isAuthenticated();
      
      // Users can create games
      allow create: if isAuthenticated() && 
        request.resource.data.whitePlayerId == request.auth.uid;
      
      // Players can update their own games (make moves)
      // Also allow invited players to update (when accepting the invite)
      allow update: if isAuthenticated() && 
        (resource.data.whitePlayerId == request.auth.uid ||
         resource.data.blackPlayerId == request.auth.uid ||
         (resource.data.invitedPlayerId != null && 
          resource.data.invitedPlayerId == request.auth.uid));
      
      // Players can delete their own games (resign/abort)
      // Also allow invited players to delete (when declining the invite)
      // CRITICAL: Allow deletion of waiting games by any authenticated user (for cleanup/admin operations)
      // This enables the "Clear All Chess Data" feature to work properly
      allow delete: if isAuthenticated() && 
        (resource.data.whitePlayerId == request.auth.uid ||
         resource.data.blackPlayerId == request.auth.uid ||
         (resource.data.invitedPlayerId != null && 
          resource.data.invitedPlayerId == request.auth.uid) ||
         // Allow deletion of waiting games by any authenticated user (for cleanup)
         resource.data.status == 'waiting');
    }
    
    // Chess matchmaking queue
    match /chess_matchmaking/{queueId} {
      // Users can read all queue entries (needed for matchmaking)
      allow read: if isAuthenticated();
      
      // Users can create their own queue entry
      allow create: if isAuthenticated() && 
        request.resource.data.userId == request.auth.uid;
      
      // Users can update their own queue entry
      allow update: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
      
      // Users can delete their own queue entry
      allow delete: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
    }
    
    // Chess invites collection (for family chess challenges)
    match /invites/{inviteId} {
      // CRITICAL FIX: Allow authenticated users to read ALL invites
      // This is needed for collection queries (.get()) to fetch all invites for deletion
      // Individual document access can still be filtered client-side for security
      allow read: if isAuthenticated();
      
      // Users can create invites (when challenging someone)
      allow create: if isAuthenticated() && 
        request.resource.data.sender == request.auth.uid;
      
      // Users can update invites they sent or received
      allow update: if isAuthenticated() && 
        (resource.data.sender == request.auth.uid ||
         resource.data.targetUser == request.auth.uid);
      
      // Users can delete invites they sent
      // CRITICAL: Also allow deletion of pending invites by any authenticated user (for cleanup)
      // This enables the "Clear All Chess Data" feature to work properly
      allow delete: if isAuthenticated() && 
        (resource.data.sender == request.auth.uid ||
         resource.data.status == 'pending');
    }
    
    // FCM messages collection (for triggering Cloud Functions)
    match /fcm_messages/{messageId} {
      // Allow authenticated users to create FCM message triggers
      allow create: if isAuthenticated();
      // CRITICAL FIX: Allow authenticated users to read and delete FCM messages
      // This is needed for the "Clear All Chess Data" feature to delete chess-related FCM messages
      allow read: if isAuthenticated();
      allow delete: if isAuthenticated();
      // No updates allowed (immutable)
      allow update: if false;
    }
    
    // Helper function to check if request is from a service account
    // Service accounts authenticate via IAM and always have token.email set
    // Regular users authenticate via Firebase Auth and may not have token.email
    // Simple check: if authenticated with token.email and no user document, it's a service account
    function isServiceAccount() {
      return isAuthenticated() && 
        request.auth.token.email != null &&
        !userDocumentExists();
    }
    
    // Helper function to check if user is Tester or Admin (safely handles missing document)
    // Checks all possible collection paths
    // Also allows service accounts (for automated scripts) - service accounts have token.email
    function isTesterOrAdmin() {
      // Allow service accounts (for automated UAT test case creation)
      // Service accounts always have token.email set when authenticating via IAM
      return isServiceAccount() || (
        isAuthenticated() && userDocumentExists() && (
          (exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
           'roles' in get(/databases/$(database)/documents/users/$(request.auth.uid)).data &&
           get(/databases/$(database)/documents/users/$(request.auth.uid)).data.roles.hasAny(['tester', 'admin', 'Admin'])) ||
          (exists(/databases/$(database)/documents/dev_users/$(request.auth.uid)) &&
           'roles' in get(/databases/$(database)/documents/dev_users/$(request.auth.uid)).data &&
           get(/databases/$(database)/documents/dev_users/$(request.auth.uid)).data.roles.hasAny(['tester', 'admin', 'Admin'])) ||
          (exists(/databases/$(database)/documents/test_users/$(request.auth.uid)) &&
           'roles' in get(/databases/$(database)/documents/test_users/$(request.auth.uid)).data &&
           get(/databases/$(database)/documents/test_users/$(request.auth.uid)).data.roles.hasAny(['tester', 'admin', 'Admin']))
        )
      );
    }
    
    // UAT Test Rounds collection (unprefixed - shared test artifacts)
    match /uat_test_rounds/{roundId} {
      // Allow authenticated testers/admins to read test rounds
      allow read: if isTesterOrAdmin();
      
      // Allow authenticated testers/admins to create test rounds
      allow create: if isTesterOrAdmin() && 
        request.resource.data.createdBy == request.auth.uid;
      
      // Allow authenticated testers/admins to update test rounds
      allow update: if isTesterOrAdmin();
      
      // Allow authenticated testers/admins to delete test rounds
      allow delete: if isTesterOrAdmin();
      
      // Test cases subcollection
      match /test_cases/{testCaseId} {
        // Allow authenticated testers/admins to read test cases
        allow read: if isTesterOrAdmin();
        
        // Allow authenticated testers/admins to create test cases
        allow create: if isTesterOrAdmin();
        
        // Allow authenticated testers/admins to update test cases
        allow update: if isTesterOrAdmin();
        
        // Allow authenticated testers/admins to delete test cases
        allow delete: if isTesterOrAdmin();
        
        // Sub-test cases subcollection
        match /sub_test_cases/{subTestCaseId} {
          // Allow authenticated testers/admins to read sub-test cases
          allow read: if isTesterOrAdmin();
          
          // Allow authenticated testers/admins to create sub-test cases
          allow create: if isTesterOrAdmin();
          
          // Allow authenticated testers/admins to update sub-test cases
          allow update: if isTesterOrAdmin();
          
          // Allow authenticated testers/admins to delete sub-test cases
          allow delete: if isTesterOrAdmin();
        }
      }
    }
    
    // Dev UAT Test Rounds collection (prefixed - dev environment test artifacts)
    match /dev_uat_test_rounds/{roundId} {
      // Allow service accounts (for automated scripts) and authenticated testers/admins
      allow read: if isTesterOrAdmin() || isServiceAccount();
      
      // Allow service accounts to create (for automated test case creation)
      // Also allow authenticated testers/admins to create test rounds
      allow create: if isServiceAccount() || (isTesterOrAdmin() && 
        request.resource.data.createdBy == request.auth.uid);
      
      // Allow service accounts and authenticated testers/admins to update test rounds
      allow update: if isTesterOrAdmin() || isServiceAccount();
      
      // Allow service accounts and authenticated testers/admins to delete test rounds
      allow delete: if isTesterOrAdmin() || isServiceAccount();
      
      // Test cases subcollection
      match /test_cases/{testCaseId} {
        // Allow service accounts and authenticated testers/admins to read test cases
        allow read: if isTesterOrAdmin() || isServiceAccount();
        
        // Allow service accounts and authenticated testers/admins to create test cases
        allow create: if isTesterOrAdmin() || isServiceAccount();
        
        // Allow service accounts and authenticated testers/admins to update test cases
        allow update: if isTesterOrAdmin() || isServiceAccount();
        
        // Allow service accounts and authenticated testers/admins to delete test cases
        allow delete: if isTesterOrAdmin() || isServiceAccount();
        
        // Sub-test cases subcollection
        match /sub_test_cases/{subTestCaseId} {
          // Allow service accounts and authenticated testers/admins to read sub-test cases
          allow read: if isTesterOrAdmin() || isServiceAccount();
          
          // Allow service accounts and authenticated testers/admins to create sub-test cases
          allow create: if isTesterOrAdmin() || isServiceAccount();
          
          // Allow service accounts and authenticated testers/admins to update sub-test cases
          allow update: if isTesterOrAdmin() || isServiceAccount();
          
          // Allow service accounts and authenticated testers/admins to delete sub-test cases
          allow delete: if isTesterOrAdmin() || isServiceAccount();
        }
      }
    }
    
    // Test UAT Test Rounds collection (prefixed - test/qa environment test artifacts)
    match /test_uat_test_rounds/{roundId} {
      // Allow authenticated testers/admins to read test rounds
      allow read: if isTesterOrAdmin();
      
      // Allow authenticated testers/admins to create test rounds
      allow create: if isTesterOrAdmin() && 
        request.resource.data.createdBy == request.auth.uid;
      
      // Allow authenticated testers/admins to update test rounds
      allow update: if isTesterOrAdmin();
      
      // Allow authenticated testers/admins to delete test rounds
      allow delete: if isTesterOrAdmin();
      
      // Test cases subcollection
      match /test_cases/{testCaseId} {
        // Allow authenticated testers/admins to read test cases
        allow read: if isTesterOrAdmin();
        
        // Allow authenticated testers/admins to create test cases
        allow create: if isTesterOrAdmin();
        
        // Allow authenticated testers/admins to update test cases
        allow update: if isTesterOrAdmin();
        
        // Allow authenticated testers/admins to delete test cases
        allow delete: if isTesterOrAdmin();
        
        // Sub-test cases subcollection
        match /sub_test_cases/{subTestCaseId} {
          // Allow authenticated testers/admins to read sub-test cases
          allow read: if isTesterOrAdmin();
          
          // Allow authenticated testers/admins to create sub-test cases
          allow create: if isTesterOrAdmin();
          
          // Allow authenticated testers/admins to update sub-test cases
          allow update: if isTesterOrAdmin();
          
          // Allow authenticated testers/admins to delete sub-test cases
          allow delete: if isTesterOrAdmin();
        }
      }
    }
    
    // Extended family relationships (top-level collection)
    match /extended_family_relationships/{relationshipId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && request.auth.uid == request.resource.data.addedBy;
      allow update: if isAuthenticated() && request.auth.uid == resource.data.addedBy;
      allow delete: if isAuthenticated() && request.auth.uid == resource.data.addedBy;
    }
    
    // Extended family privacy settings (top-level collection)
    match /extended_family_privacy/{privacyId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && request.auth.uid == request.resource.data.userId;
      allow update: if isAuthenticated() && request.auth.uid == resource.data.userId;
    }
    
    // Student profiles (top-level collection for homeschooling)
    match /student_profiles/{profileId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && request.auth.uid == request.resource.data.createdBy;
      allow update: if isAuthenticated() && request.auth.uid == resource.data.createdBy;
      allow delete: if isAuthenticated() && request.auth.uid == resource.data.createdBy;
    }
    
    // Dev extended family relationships
    match /dev_extended_family_relationships/{relationshipId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && request.auth.uid == request.resource.data.addedBy;
      allow update: if isAuthenticated() && request.auth.uid == resource.data.addedBy;
      allow delete: if isAuthenticated() && request.auth.uid == resource.data.addedBy;
    }
    
    // Dev extended family privacy
    match /dev_extended_family_privacy/{privacyId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && request.auth.uid == request.resource.data.userId;
      allow update: if isAuthenticated() && request.auth.uid == resource.data.userId;
    }
    
    // Dev student profiles
    match /dev_student_profiles/{profileId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && request.auth.uid == request.resource.data.createdBy;
      allow update: if isAuthenticated() && request.auth.uid == resource.data.createdBy;
      allow delete: if isAuthenticated() && request.auth.uid == resource.data.createdBy;
    }
    
    // Test extended family relationships
    match /test_extended_family_relationships/{relationshipId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && request.auth.uid == request.resource.data.addedBy;
      allow update: if isAuthenticated() && request.auth.uid == resource.data.addedBy;
      allow delete: if isAuthenticated() && request.auth.uid == resource.data.addedBy;
    }
    
    // Test extended family privacy
    match /test_extended_family_privacy/{privacyId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && request.auth.uid == request.resource.data.userId;
      allow update: if isAuthenticated() && request.auth.uid == resource.data.userId;
    }
    
    // Test student profiles
    match /test_student_profiles/{profileId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && request.auth.uid == request.resource.data.createdBy;
      allow update: if isAuthenticated() && request.auth.uid == resource.data.createdBy;
      allow delete: if isAuthenticated() && request.auth.uid == resource.data.createdBy;
    }
  }
}

